<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTK.js Viewer with Color Picker and Double-Sided Cropping</title>
    <script src="https://unpkg.com/vtk.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #container {
            width: 100%;
            height: 100%;
            display: flex;
        }
        #vtkContainer {
            flex-grow: 1;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .slider-container label {
            min-width: 30px;
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="vtkContainer"></div>
        <div id="controls">
            <h3>Controls</h3>
            <label for="colorPicker">Surface Color:</label>
            <input type="color" id="colorPicker" value="#FF0000"><br><br>
            <button id="toggleBoundingBox">Toggle Bounding Box</button><br><br>
            <button id="enableCropping">Enable Cropping</button><br><br>
            <div id="cropControls" style="display: none;">
                <div class="slider-container">
                    <label for="xMinSlider">X min:</label>
                    <input type="range" id="xMinSlider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="slider-container">
                    <label for="xMaxSlider">X max:</label>
                    <input type="range" id="xMaxSlider" min="0" max="1" step="0.01" value="1">
                </div>
                <div class="slider-container">
                    <label for="yMinSlider">Y min:</label>
                    <input type="range" id="yMinSlider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="slider-container">
                    <label for="yMaxSlider">Y max:</label>
                    <input type="range" id="yMaxSlider" min="0" max="1" step="0.01" value="1">
                </div>
                <div class="slider-container">
                    <label for="zMinSlider">Z min:</label>
                    <input type="range" id="zMinSlider" min="0" max="1" step="0.01" value="0">
                </div>
                <div class="slider-container">
                    <label for="zMaxSlider">Z max:</label>
                    <input type="range" id="zMaxSlider" min="0" max="1" step="0.01" value="1">
                </div>
            </div>
        </div>
    </div>

    <script>
        // VTK.js setup
        const vtkFullScreenRenderWindow = vtk.Rendering.Misc.vtkFullScreenRenderWindow;
        const vtkActor = vtk.Rendering.Core.vtkActor;
        const vtkMapper = vtk.Rendering.Core.vtkMapper;
        const vtkPLYReader = vtk.IO.Geometry.vtkPLYReader;
        const vtkOutlineFilter = vtk.Filters.General.vtkOutlineFilter;
        const vtkPlane = vtk.Common.DataModel.vtkPlane;

        // Create renderer and add to HTML
        const fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
            rootContainer: document.querySelector('#vtkContainer'),
            background: [0.2, 0.3, 0.4]
        });
        const renderer = fullScreenRenderer.getRenderer();
        const renderWindow = fullScreenRenderer.getRenderWindow();

        // Create a surface from PLY file
        const reader = vtkPLYReader.newInstance();
        reader.setUrl('two_fasciculus.ply').then(() => {
            const polydata = reader.getOutputData(0);
            const mapper = vtkMapper.newInstance();
            const actor = vtkActor.newInstance();

            actor.setMapper(mapper);
            mapper.setInputData(polydata);

            renderer.addActor(actor);
            renderer.resetCamera();
            renderWindow.render();

            // Color picker functionality
            const colorPicker = document.getElementById('colorPicker');
            colorPicker.addEventListener('input', (event) => {
                const color = event.target.value;
                actor.getProperty().setColor(...hexToRgb(color));
                renderWindow.render();
            });

            // Bounding box functionality
            let outlineActor = null;
            const toggleBoundingBox = document.getElementById('toggleBoundingBox');
            toggleBoundingBox.addEventListener('click', () => {
                if (outlineActor) {
                    renderer.removeActor(outlineActor);
                    outlineActor = null;
                } else {
                    const outline = vtkOutlineFilter.newInstance();
                    outline.setInputData(polydata);
                    const outlineMapper = vtkMapper.newInstance();
                    outlineMapper.setInputConnection(outline.getOutputPort());
                    outlineActor = vtkActor.newInstance();
                    outlineActor.setMapper(outlineMapper);
                    renderer.addActor(outlineActor);
                }
                renderWindow.render();
            });

            // Double-sided Cropping functionality
            const enableCropping = document.getElementById('enableCropping');
            const cropControls = document.getElementById('cropControls');
            const sliders = {
                xMin: document.getElementById('xMinSlider'),
                xMax: document.getElementById('xMaxSlider'),
                yMin: document.getElementById('yMinSlider'),
                yMax: document.getElementById('yMaxSlider'),
                zMin: document.getElementById('zMinSlider'),
                zMax: document.getElementById('zMaxSlider')
            };

            let clippingPlanes = [
                vtkPlane.newInstance(), // X min
                vtkPlane.newInstance(), // X max
                vtkPlane.newInstance(), // Y min
                vtkPlane.newInstance(), // Y max
                vtkPlane.newInstance(), // Z min
                vtkPlane.newInstance()  // Z max
            ];

            enableCropping.addEventListener('click', () => {
                if (cropControls.style.display === 'none') {
                    cropControls.style.display = 'block';
                    enableCropping.textContent = 'Disable Cropping';
                    clippingPlanes.forEach(plane => mapper.addClippingPlane(plane));
                } else {
                    cropControls.style.display = 'none';
                    enableCropping.textContent = 'Enable Cropping';
                    mapper.removeAllClippingPlanes();
                }
                renderWindow.render();
            });

            function updateClippingPlanes() {
                const bounds = polydata.getBounds();
                
                // X-axis clipping planes
                clippingPlanes[0].setNormal([1, 0, 0]);
                clippingPlanes[1].setNormal([-1, 0, 0]);
                clippingPlanes[0].setOrigin([
                    bounds[0] + sliders.xMin.value * (bounds[1] - bounds[0]),
                    0,
                    0
                ]);
                clippingPlanes[1].setOrigin([
                    bounds[0] + sliders.xMax.value * (bounds[1] - bounds[0]),
                    0,
                    0
                ]);

                // Y-axis clipping planes
                clippingPlanes[2].setNormal([0, 1, 0]);
                clippingPlanes[3].setNormal([0, -1, 0]);
                clippingPlanes[2].setOrigin([
                    0,
                    bounds[2] + sliders.yMin.value * (bounds[3] - bounds[2]),
                    0
                ]);
                clippingPlanes[3].setOrigin([
                    0,
                    bounds[2] + sliders.yMax.value * (bounds[3] - bounds[2]),
                    0
                ]);

                // Z-axis clipping planes
                clippingPlanes[4].setNormal([0, 0, 1]);
                clippingPlanes[5].setNormal([0, 0, -1]);
                clippingPlanes[4].setOrigin([
                    0,
                    0,
                    bounds[4] + sliders.zMin.value * (bounds[5] - bounds[4])
                ]);
                clippingPlanes[5].setOrigin([
                    0,
                    0,
                    bounds[4] + sliders.zMax.value * (bounds[5] - bounds[4])
                ]);
                
                renderWindow.render();
            }

            Object.values(sliders).forEach(slider => {
                slider.addEventListener('input', updateClippingPlanes);
            });
        });

        // Helper function to convert hex color to RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }
    </script>
</body>
</html>